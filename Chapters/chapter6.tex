\chapter{Algorithm Details}
\label{cha:algorithm_details}

Since a general overview of genetic algorithms has already been given in \ref{sec:previous_knowledge_ga} this chapter will only cover the choices made for the particular program developed for this paper and justify these choices. Note that some alternative algorithms have been considered and sometimes even implemented, see \ref{cha:evaluation}, but due to the time constraints of this thesis not all possibilities could be covered, so in many cases there may be a better solution possible. Some of these will also be considered, but not implemented, in \ref{cha:conclusion}. 

\section{Genome Representation}
\label{sec:genome_representation}

For ease of use, a simple path representation with a fixed genome length has been chosen. As detailed in \ref{sec:path_representation} every path consists of exactly 20 parts, each subject to length and/or angle restrictions respectively. Each part is represented by an eight bit string, so the entire path consists of exactly 160 bits. This fixed length makes the application of further operations like crossover and mutation easier and also allows for a simple conversion between the path and genome representation of any given population member. 
Consequentially every 160 bit genome can be split into 20 8 bit genome parts, which can be further be assumed to consists of 4 parts: The first bit determines whether this genome part represents a line or a curve and the next 3 bits determine the length of a given path part. The last 4 bits are only considered in case of curves, for linear path parts they are ignored and set to 0. The first 3 of these 4 bits contain the angle of the curve and the last one determines whether this is a right or a left curve. 
This genome format can also be though of as a graph where, starting from left to right, every bit represents one choice in the graph, the first being curve or line, and the next being the length etc. 

\subsection{Genome Conversion}
\label{sec:genome_conversion}

For every member of the population we require three pieces of information: The path representation, needed for our evaluation, the genome representation, needed for our genetic operations, and the fitness rating. While the assignment of the rating is done by fitness function, see \ref{sec:evaluation}, we also need to be able to convert between the two representations of the path. While a conversion from path to genome representation would certainly be possible, it is not implemented since we never need it. The only part of the algorithm where we do not already have the genome before we need the corresponding path is the initial generation in which we require random paths. Since the paths are random it does not actually matter whether we first generate a genome and then obtain the path or generate a path and obtain the genome from there. We do, however, always need a function that can obtain a path from a given genome since crossover/mutation and reordering will operate on genomes and also return genomes, so since we need that function regardless of what choice we make in the initial generation it is easier to generate the genome first and then obtain the path from there.
The conversion from genome to path part is done simply by following the conventions of the genome, that is, creating a LinePathPart if the first bit is 0 and a CirclePathPart otherwise. The length in either case is 0.5 + length * 0.5, where length is the number represented by the second, third and fourth bit.
In case of a CirclePathPart we also need the angle, which is 10 + angle * 5, where angle is the number represented by the fifth, sixth and seventh bit. The last bit sets the direction to either right (0) or left (1).
This conversion is done in blocks of 8 along all 160 bits of the given genome and returns a full LinkedList of 20 path parts.

\section{Selection} % (fold)
\label{sec:imp_selection}

Three selection methods have been implemented and tested (see \ref{cha:evaluation}) and can be selected from the program, however by default it is set to use the tournament selection. The tournament size is set to 2, so 2 members will be selected at random and tested against each other. The selection size is 0.4 by default, so 40\% of the next generation will consist of member of the previous generation (disregarding mutation, which is applied to all members), the remaining 60\% will be obtained later using crossover between these 40\%. Of the two members chosen the one with the higher rating will win. Since members are chosen at random without being removed from the population it is possible for the same member to be chosen several times. This implementation is not weighted, so all members have the same chance of being chosen, but bad members obviously have a low chance of winning, though it is not impossible so long as they are pitted against an even lower member. This keeps the algorithm from starving since it keeps non-ideal members within the population. The selection process can be adjusted by changing the tournament size, a greater number of participants per tournament lowers the chances of winning for members with a low rating.

\section{Crossover} % (fold)
\label{sec:imp_crossover}

As with selection, several crossover methods have been implemented and can be selected in the program: Two-fixed-point crossover, single-bit crossover and eight-bit crossover. The later one is chosen by default, it generates a 20 Bit long mask genome randomly and then selects two parent genomes from the current population, also at random. Each Bit in the mask genome represents 8 Bit in the member genome, the value of the bit determines whether the 8 bit block for the child genome is taken from the first or second parent. A second child is also produced in every iteration which simply always gets the other parents block that was not selected for the first child. This eight-bit crossover produces very diverse children, more so than a one- or two-fixed-point crossover function where the switching between the two parents happens much less frequently, but it still preserves the path parts by only working in blocks of eight. Compared to the single bit crossover, which basically works the same but generates a 160 Bit mask and then selects single bits from the parents instead of using blocks of 8, the result is much less random and also significantly faster.
The two-fixed points crossover works similar to the eight-bit crossover, but instead of generating a mask genome to decide whether to take from the first or second parent it always selects the same bit range from the same parent, in our case bits 0 to 4 from parent 1, 5 to 15 from parent 2 and 16 to 19 from parent 1. These fixed points can of course be moved around and their number can be adjusted, however if you further increased the number while still trying to preserve the path structure you would quickly end up with something very similar to the eight-bit crossover.
A possible optimization of the eight- or two-fixed-point crossover will be discussed in \ref{cha:conclusion} as it has not been implemented yet.
As mentioned before, 40\% of the new population are obtained by selection, which leaves 60\% for crossover, so our crossover rate is set to 0.6. Only half that many operations have to be computed however since every crossover generates two children.

\section{Evaluation} % (fold)
\label{sec:imp_evaluation}

Evaluation is applied as detailed in \ref{sec:evaluation}. It iterates over the entire current population, obtains a path from every genome, obtains a simulation for every path and then assigns a rating to the path/genome according to the fitness function. 
When compared to the other genetic operations the evaluation probably holds the greatest potential for optimization as there is no fixed number of existing algorithms to choose from. The fitness function entirely depends on the problem to be worked on as well as the given representations of that problem, so it has to be created from scratch for every new task. The current implementation is rather simple and only checks how many pixels of the path are within a wall or outside the map and how far the destination reached is away from the target. Many additional variables to be considered or better ways of judging the currently considered values are possible, some of these will be discussed in \ref{cha:conclusion}.

\section{Mutation} % (fold)
\label{sec:imp_mutation}

Mutation is applied on the entire new population after crossover and is supposed to keep the algorithm from starving out by possibly re-introducing bit combinations that have been lost in previous selections. Unlike with crossover and selection there is only one algorithms for this available so the only choice to be made here is the mutation rate, which determines the probability with which any bit is chosen, this is set to 0.1 by default. The mutation operator does not care about the genome's structure, it simply generates a random number for every bit of every genome in the entire population and if the number is one (0.1\% chance) it flips the current bit.

\section{Reordering}
\label{sec:reordering}

Unlike the operators discussed so far, the reordering operator is optional and not usually part of a GA. It works by randomly choosing an individual with a certain probability, for example 0.1, and then reversing the order of bits between two points within this genome, these points are also chosen at random. In certain cases this inversion has been shown to significantly improve the performance of the GA by preventing what is called \textit{deception}\cite{8}. This can happen when certain bits in a genome are important but very far apart, which is called loose linkage. In such a case the crossover operator is likely to separate these building blocks even though they need to be together, something that were less likely to happen if the blocks were closer together. Whether the reordering operator is appropriate depends on the given problem and also the crossover operator employed. \cite{8} %Check this citation
