\chapter{Implementation}
\label{cha:implementation}

The program accompanying this work is written in C\# and uses the OpenTK Library for OpenGL graphics. Several C\# features, such as functional and object-oriented programming, have been employed, but as this program is not meant as a framework or teaching tool, no special importance has been placed on the usage of specific programming models. \\
Originally the TAO OpenGL framework was used for the Graphics implementation, but this was later dropped due to the fact that most of TAO's libraries are severely outdated and produced several problems during map drawing. OpenTK has been chosen as an alternative due its simplicity, stability and high flexibility. \\
Visual Studio 2010 was used for development, other than OpenTK, which has to be installed separately, only standard libraries were used.

\section{OpenTK}
\label{sec:opentk}

OpenTK is a free OpenGL library for .Net/Mono languages and is available across all Windows, Linux, Mac and other Unix-based Systems. It supports multi-monitor setups, a wide range of input devices as well as most GUI options. It also comes with integrated math toolkits for vectors, matrices etc. as well as type-safe bindings, automatic extension loading, error checking and inline documentation. OpenTK itself is also written in C\#, but is compatible with all .Net/Mono languages\cite{36}.

\section{Map}
\label{sec:map}

The map has to be given as a simple image (.png) file in which empty areas are white and walls are black. While a different representation of the environment may be better suited for collision detection, this simple map format makes it easier to create new maps for any given area. The map is assumed to be 2 dimensional, so height differences are not considered, and only about 40x20 m in size. The default image size is 1024x512 pixels, other sizes are possible but may lead to problems with the map overlay so any map should be re-sized to this. On start-up, a boolean array of the same size as the map is created and filled with values obtained from the given image, where every white pixel is true and every black pixel is false. This array is used for collision detection while the map itself is only used as a texture background for the GUI.

\section{Vehicle}
\label{sec:vehicle}

The vehicle is saved in a format similar to the one described in \ref{sec:previous_knowledge_vehicle} however, all vehicle parts are saved with absolute positions instead of using values relative to the previous trailer. While this requires more space it makes collision detection and drawing of the vehicle a lot easier. For every element of the vehicle the values M and L are saved, which determine the length of the front and rear of the trailer respectively, measured from the axle. In accordance with that representation, the tractive unit is assumed to be 2 parts with a rigid coupling in between. A tractive unit without any trailers is generated randomly every time the program is started, so one can immediately start planning a path without having to configure a vehicle first every time. If a specific vehicle is required, adjustments can be made in the vehicle tab of the GUI. In this tab, M and L can be adjusted for every part of the vehicle, more trailers can be added and vehicles can be saved for later use. While the program can theoretically handle an infinite number of trailers it is currently meant to be used with only one.\\
For a complete representation of the vehicle more information is required than just the size of every given part, that is, the configuration of the vehicle, found in the configuration tab. This configuration contains the starting point of the vehicle, as well as the angles between all its elements. Effectively, only the angles can be adjusted, the position of the steering vehicle is assumed to be the same as the starting position of the path, set in the main tab, and all other vehicle parts' positions are obtained from that starting position and the elements' angles. The configuration, too, can be saved and loaded.

\section{Path Representation}
\label{sec:path_representation}

To make the representation within the GA easier, certain limitations are enforced on the paths generated by this program, however, most of these are not really constraining since a general-n-trailer is limited in its possible configuration space to begin with. In order to get a fixed genome length we assume every path to be made up of exactly 20 parts. Paths of length 0 are not possible since any given path part has a minimum length of 0.5 meters, similarly, paths longer than 80 meters are not possible but should not be necessary either due to the limitation of the map-size.\\
A path is represented as a LinkedList of path primitives, which can be either a curve or a line. A curve, or CirclePathPart, has an angle, a start angle, an end angle, a radius, a center and a direction, that is, whether it is a left or a right curve. A LinePathPart has a start, end and direction, as well as a speed and a boolean value determining whether the vehicle is driving in reverse or not, however neither of these are used in the current implementation of the program and are simply set to default values. The values of any given path part are either set randomly (\ref{sec:generation_0}), obtained from a newly generated genome (\ref{cha:algorithm_details}) or set by the previous path part, for example, the direction of a LinePathPart can only be the direction of the previous PathPart since no rough edges are permitted.
Due to the selected information encoded in the genome the maximum value of any of these variables as well as the step size between these values are limited. Any given  path part can be between 0.5 and 4 meters long and, in case it is a curve, have an angle between 10$^{\circ}$ and 45$^{\circ}$ in steps of 5$^{\circ}$. A more detailed path can easily be achieved by extending the length of the genome (\ref{sec:genome_representation}), but this would also slow down computation.

\section{Generation 0} % (fold)
\label{sec:generation_0}

The initial generation, also known as generation 0, is obtained by generating random paths and converting these into the genome format, see \ref{sec:genome_representation} for further details on the exact representation. A function generatePath() in the PathPrimitives class is used to randomly generate a path of a fixed length, by default 20 path parts, as well as calculating the corresponding genome. This function generatePath() uses the function getRandomPathPart() of the same class, which generates a path part within the limitations given in \ref{sec:path_representation}.
After enough paths have been obtained, all of them are evaluated.

\section{Evaluation} % (fold)
\label{sec:evaluation}

The evaluation is done using a simple weighted fitness function which considers both the distance from the end of the path to the original goal as well as the number of collisions, leaving the map is also counted towards the collision value. The weight of these two factors can be adjusted but is by default set to 2 to 3 for the goal distance. More factors, like the length of the path, the number of turns or the minimal distance to obstacles could be considered in this function as well, but are currently not implemented. It should be noted that the path evaluated here is not the path obtained from the GA directly, but the generated path after it has gone through the simulation class, which uses the path optimization from AG Echtzeitysteme to transform it into a path drivable by the given vehicle. 

\section{Generation 1+} % (fold)
\label{sec:generation_1+}

Further generations are evaluated in the same way as the initial one, but are obtained by genetic crossing and not randomly. The exact process used in this implementation of the genetic algorithm is described in \ref{cha:algorithm_details}.

\section{GUI}
\label{sec:gui}

The full GUI can be seen in fig. \ref{pic:gui_full_main}. On the left we can see a sample map which can be replaced either in the code or by clicking the "`Load Map"' button on the right and providing a fitting image, see \ref{sec:map}. Black areas on the map are obstacles while white areas are available. The blue dot marks our target destination, the red one our starting point. The lines at the red dot are our current vehicle, the tiny red dot within our vehicle is a coupling, in this case a rigid one since we only have a tractive unit by default. On the right of the map we have buttons for loading a new map, starting the path finding algorithm (Start), starting an entire set of iterations for evaluation purposes (Evaluation), drawing a single random path (Start Path) and obtaining a simulation for a given path (Drive). Next to the "`Drive"' button is a small text box which shows the current generation the algorithm is computing. The current path's genome is shown in the box below those five buttons, every line consists of 8 numbers and represents exactly one path part, as such there are 20 lines. This box is usually read-only, but it can be modified by unchecking the "`Genome Read Only"' box next to it. This way, a previously saved path's genome can be put in and a simulation can be obtained by pressing "`Drive"'. The "`Show Current End"' button shows the configuration of the vehicle at the end of the current path, this could be used in the fitness function but is not yet implemented. The "`Debug Population"' check box causes the algorithm to stop after each generation and output all computed paths along with their rating. \\
The GUI tab on the right allows us to save, load and modify our general-n-trailer. Each vehicle part is defined by its $M$ and $L$ values, see \ref{sec:previous_knowledge_vehicle}. \\
The configuration tab allows the modification of the current vehicle's position and steering angles. Just like the vehicle, this configuration can be saved, loaded and reset, it should be noted that it is only possible to load a configuration when it fits the current vehicle's number of trailers. In the same tab, the start and end coordinates can bet set, the colours correspond to the points on the map. By selecting "`End Conf"' on the right a target configuration can be set, however, this is not needed at the moment since only the distance to the destination is considered in the fitness function, not the entire configuration.

\begin{figure}[b]
\centering
\includegraphics[width=0.75\textwidth]{./Chapters/Figures/gui_full_main.png}
\caption{The full view of the GUI with a sample map on the left and the Main window on the right\label{pic:gui_full_main}}
\end{figure}
